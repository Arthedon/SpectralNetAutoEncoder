import torch
import numpy as np

from Trainer.SpectralNetAETrainer import SpectralNetAETrainer
from spectralnet._trainers import AETrainer, SiameseTrainer
from spectralnet._utils import build_ann

from sklearn.cluster import KMeans


class SpectralNetAE:
    def __init__(
        self,
        n_clusters: int,
        use_ae: bool = False,
        use_siamese: bool = False,
        is_sparse_graph: bool = False,
        ae_hiddens: list = [512, 512, 2048, 10],
        ae_epochs: int = 40,
        ae_lr: float = 1e-3,
        ae_lr_decay: float = 0.1,
        ae_min_lr: float = 1e-7,
        ae_patience: int = 10,
        ae_batch_size: int = 256,
        siamese_hiddens: list = [1024, 1024, 512, 10],
        siamese_epochs: int = 30,
        siamese_lr: float = 1e-3,
        siamese_lr_decay: float = 0.1,
        siamese_min_lr: float = 1e-7,
        siamese_patience: int = 10,
        siamese_n_nbg: int = 2,
        siamese_use_approx: bool = False,
        siamese_batch_size: int = 128,
        spectral_config: dict = {'hiddens': [1024, 1024, 512, 10]},
        spectral_max_epochs: int = 30,
        spectral_lr: float = 1e-3,
        spectral_lr_decay: float = 0.1,
        spectral_min_lr: float = 1e-8,
        spectral_patience: int = 10,
        spectral_batch_size: int = 1024,
        spectral_num_neighbours: int = 30,
        spectral_scale_k: int = 15,
        spectral_is_local_scale: bool = True,
        spectral_is_normalized: bool = False,
        spectral_alpha: float = 0.001,
        spectral_tolerance: float = 1e-4,
        spectral_conv: bool = False
    ):
        """SpectralNet is a class for implementing a Deep learning model that performs spectral clustering.
        This model optionally utilizes Autoencoders (AE) and Siamese networks for training.

        Parameters
        ----------
        n_clusters : int
            The number of clusters to be generated by the SpectralNet algorithm.
            Also used for the dimention of the projection subspace.

        use_ae : bool, optional (default=False)
            Specifies whether to use the Autoencoder (AE) network as part of the training process.

        use_siamese : bool, optional (default=False)
                Specifies whether to use the Siamese network as part of the training process.

        is_sparse_graph : bool, optional (default=False)
            Specifies whether the graph Laplacian created from the data is sparse.

        ae_hiddens : list, optional (default=[512, 512, 2048, 10])
            The number of hidden units in each layer of the Autoencoder network.

        ae_epochs : int, optional (default=30)
            The number of epochs to train the Autoencoder network.

        ae_lr : float, optional (default=1e-3)
            The learning rate for the Autoencoder network.

        ae_lr_decay : float, optional (default=0.1)
            The learning rate decay factor for the Autoencoder network.

        ae_min_lr : float, optional (default=1e-7)
            The minimum learning rate for the Autoencoder network.

        ae_patience : int, optional (default=10)
            The number of epochs to wait before reducing the learning rate for the Autoencoder network.

        ae_batch_size : int, optional (default=256)
            The batch size used during training of the Autoencoder network.

        siamese_hiddens : list, optional (default=[1024, 1024, 512, 10])
            The number of hidden units in each layer of the Siamese network.

        siamese_max_epochs : int, optional (default=30)
            The maximum number of epochs to train the Siamese network.

        siamese_lr : float, optional (default=1e-3)
            The learning rate for the Siamese network.

        siamese_lr_decay : float, optional (default=0.1)
            The learning rate decay factor for the Siamese network.

        siamese_min_lr : float, optional (default=1e-7)
            The minimum learning rate for the Siamese network.

        siamese_patience : int, optional (default=10)
            The number of epochs to wait before reducing the learning rate for the Siamese network.

        siamese_n_nbg : int, optional (default=2)
            The number of nearest neighbors to consider as 'positive' pairs by the Siamese network.

        siamese_use_approx : bool, optional (default=False)
            Specifies whether to use Annoy instead of KNN for computing nearest neighbors,
            particularly useful for large datasets.

        siamese_batch_size : int, optional (default=256)
            The batch size used during training of the Siamese network.

        spectral_config : dict, optional (hiddens=[1024, 1024, 512, 10])
            The number of hidden units in each layer of the Spectral network.
            Or configuration for convolutionnal layers

        spectral_max_epochs : int, optional (default=30)
            The maximum number of epochs to train the Spectral network.

        spectral_lr : float, optional (default=1e-3)
            The learning rate for the Spectral network.

        spectral_lr_decay : float, optional (default=0.1)
            The learning rate decay factor

        spectral_is_normalized : bool, optional (default=False)
            Whether to use normalized Laplacian or not

        spectral_alpha : float, optional (default=0.001)
            Regularization term (importance of reconstruction in the loss computation)

        spectral_tolerance : float, optional (default=1e-4)
            Minimum difference between two successive loss

        spectral_conv : bool, optional (default=False)
            If SpectralNetAE use convolution layers instead of linear layers"""

        self.n_clusters = n_clusters
        self.use_ae = use_ae
        self.use_siamese = use_siamese
        self.is_sparse_graph = is_sparse_graph
        self.ae_hiddens = ae_hiddens
        self.ae_epochs = ae_epochs
        self.ae_lr = ae_lr
        self.ae_lr_decay = ae_lr_decay
        self.ae_min_lr = ae_min_lr
        self.ae_patience = ae_patience
        self.ae_batch_size = ae_batch_size
        self.siamese_hiddens = siamese_hiddens
        self.siamese_epochs = siamese_epochs
        self.siamese_lr = siamese_lr
        self.siamese_lr_decay = siamese_lr_decay
        self.siamese_min_lr = siamese_min_lr
        self.siamese_patience = siamese_patience
        self.siamese_n_nbg = siamese_n_nbg
        self.siamese_use_approx = siamese_use_approx
        self.siamese_batch_size = siamese_batch_size
        self.spectral_config = spectral_config
        self.spectral_max_epochs = spectral_max_epochs
        self.spectral_lr = spectral_lr
        self.spectral_lr_decay = spectral_lr_decay
        self.spectral_min_lr = spectral_min_lr
        self.spectral_patience = spectral_patience
        self.spectral_num_neighbours = spectral_num_neighbours
        self.spectral_scale_k = spectral_scale_k
        self.spectral_is_local_scale = spectral_is_local_scale
        self.spectral_batch_size = spectral_batch_size
        self.spectral_is_normalized = spectral_is_normalized
        self.spectral_alpha = spectral_alpha
        self.spectral_tolerance = spectral_tolerance
        self.use_conv = spectral_conv
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

        print(f"Working on {self.device} ...")

        if not spectral_conv:
            self._validate_spectral_hiddens()

    def _validate_spectral_hiddens(self):
        """Validates the number of hidden units in each layer of the Spectral network."""

        if self.spectral_config['hiddens'][-1] != self.n_clusters:
            raise ValueError(
                "The number of units in the last layer of spectral_hiddens network must be equal to the number of clusters or components."
            )

    def fit(self, X: torch.Tensor, y: torch.Tensor = None):
        """Performs the main training loop for the SpectralNet model.

        Parameters
        ----------
        X : torch.Tensor
            Data to train the networks on.

        y : torch.Tensor, optional
            Labels in case there are any. Defaults to None.
        """
        self._X = X
        ae_config = {
            "hiddens": self.ae_hiddens,
            "epochs": self.ae_epochs,
            "lr": self.ae_lr,
            "lr_decay": self.ae_lr_decay,
            "min_lr": self.ae_min_lr,
            "patience": self.ae_patience,
            "batch_size": self.ae_batch_size,
        }

        siamese_config = {
            "hiddens": self.siamese_hiddens,
            "epochs": self.siamese_epochs,
            "lr": self.siamese_lr,
            "lr_decay": self.siamese_lr_decay,
            "min_lr": self.siamese_min_lr,
            "patience": self.siamese_patience,
            "n_nbg": self.siamese_n_nbg,
            "use_approx": self.siamese_use_approx,
            "batch_size": self.siamese_batch_size,
        }

        spectral_config = {
            "architecture": self.spectral_config,
            "max_epochs": self.spectral_max_epochs,
            "lr": self.spectral_lr,
            "lr_decay": self.spectral_lr_decay,
            "min_lr": self.spectral_min_lr,
            "patience": self.spectral_patience,
            "num_neighbours": self.spectral_num_neighbours,
            "scale_k": self.spectral_scale_k,
            "is_local_scale": self.spectral_is_local_scale,
            "batch_size": self.spectral_batch_size,
            "is_normalized": self.spectral_is_normalized,
            "alpha": self.spectral_alpha,
            "tolerance": self.spectral_tolerance,
            "use_convolution": self.use_conv
        }

        if self.use_ae:
            self.ae_trainer = AETrainer(config=ae_config, device=self.device)
            self.ae_net = self.ae_trainer.train(X)
            X = self.ae_trainer.embed(X)

        if self.use_siamese:
            self.siamese_trainer = SiameseTrainer(
                config=siamese_config, device=self.device
            )
            X_siamese = X.view(X.size(0), -1)
            self.siamese_net = self.siamese_trainer.train(X_siamese)
        else:
            self.siamese_net = None

        is_sparse = self.is_sparse_graph
        if is_sparse:
            build_ann(X)

        self.spectral_ae_trainer = SpectralNetAETrainer(
            config=spectral_config, device=self.device, is_sparse=is_sparse
        )
        self.spec_ae_net, train_loss_count, valid_loss_count, spectral_train_loss_count, spectral_valid_loss_count = self.spectral_ae_trainer.train(X, y, self.siamese_net)
        return train_loss_count, valid_loss_count, spectral_train_loss_count, spectral_valid_loss_count

    def predict(self, X: torch.Tensor) -> np.ndarray:
        """Try to reconstruct the inputs

        Parameters
        ----------
        X : torch.Tensor
            Data to reconstruct.

        Returns
        -------
        torch.Tensor
            Reconstruction.
        """
        if self.use_conv == False:
            X = X.view(X.size(0), -1)
        X = X.to(self.device)

        with torch.no_grad():
            output = self.spec_ae_net(X, self.spectral_ae_trainer.is_normalized, self.spectral_ae_trainer.siamese_net)

        return output

    def predict_clusters(self, X: torch.Tensor) -> np.ndarray:
        """Predicts the cluster assignments for the given data.

        Parameters
        ----------
        X : torch.Tensor
            Data to be clustered.

        Returns
        -------
        np.ndarray
            The cluster assignments for the given data.
        """
        if self.use_conv == False:
            X = X.view(X.size(0), -1)
        X = X.to(self.device)

        with torch.no_grad():
            if self.use_ae:
                X = self.ae_net.encode(X)
            self.embeddings_ = self.spec_ae_net.encode(X, update_orth_weights=False)
            self.embeddings_ = self.embeddings_.detach().cpu().numpy()

        cluster_assignments = self._get_clusters_by_kmeans(self.embeddings_)
        return cluster_assignments

    def _get_clusters_by_kmeans(self, embeddings: np.ndarray) -> np.ndarray:
        """Performs k-means clustering on the spectral-embedding space.

        Parameters
        ----------
        embeddings : np.ndarray
            The spectral-embedding space.

        Returns
        -------
        np.ndarray
            The cluster assignments for the given data.
        """

        kmeans = KMeans(n_clusters=self.n_clusters, n_init=10).fit(embeddings)
        cluster_assignments = kmeans.predict(embeddings)
        return cluster_assignments